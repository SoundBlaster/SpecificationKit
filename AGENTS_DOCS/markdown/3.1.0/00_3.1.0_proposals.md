# SpecificationKit 3.1.0 — Proposals

This document proposes extensions that restore and formalize previously referenced but unsupported ComparativeSpec capabilities: statistical comparisons, dynamic RHS comparisons, and a small multi-criteria builder.

## Goals
- Add first-class helpers for common statistical comparisons.
- Support comparing a left-hand extracted value against a right-hand value derived dynamically from context.
- Provide an ergonomic builder to compose multiple comparative checks with AND/OR.
- Keep backward compatibility with the 3.0 ComparativeSpec surface.

## Non-Goals
- Change existing ComparativeSpec initializers or remove any current APIs.
- Introduce heavy dependencies for statistics; keep implementations lightweight.

---

## 1) Statistical Comparisons

Add convenience factories that derive reference values from a collection in the same context. These return `ComparativeSpec<Context, Value>` using internal `.custom` comparators so they compose like any other spec.

Constraints: `Value: FloatingPoint` (for mean, std. deviation, percentile math).

### APIs
```swift
extension ComparativeSpec where Value: FloatingPoint {
    /// True when value at `keyPath` is strictly greater than the average of `dataKeyPath`.
    public static func aboveAverage(
        comparing keyPath: KeyPath<Context, Value>,
        from dataKeyPath: KeyPath<Context, [Value]>,
        minCount: Int = 1,
        inclusive: Bool = false
    ) -> ComparativeSpec<Context, Value>

    /// True when value at `keyPath` is strictly less than the average of `dataKeyPath`.
    public static func belowAverage(
        comparing keyPath: KeyPath<Context, Value>,
        from dataKeyPath: KeyPath<Context, [Value]>,
        minCount: Int = 1,
        inclusive: Bool = false
    ) -> ComparativeSpec<Context, Value>

    /// True when value at `keyPath` is >= the given percentile of `dataKeyPath`.
    public static func percentile(
        _ p: Int, // 0...100
        comparing keyPath: KeyPath<Context, Value>,
        from dataKeyPath: KeyPath<Context, [Value]>,
        minCount: Int = 1,
        inclusive: Bool = true
    ) -> ComparativeSpec<Context, Value>

    /// True when value at `keyPath` is beyond N standard deviations from the mean of `dataKeyPath`.
    public static func isOutlier(
        comparing keyPath: KeyPath<Context, Value>,
        from dataKeyPath: KeyPath<Context, [Value]>,
        beyondStandardDeviations n: Value,
        minCount: Int = 2
    ) -> ComparativeSpec<Context, Value>
}
```

### Semantics
- If the collection at `dataKeyPath` is `[]` or has fewer than `minCount` items, return `false`.
- `inclusive` chooses `>=` vs `>` (and `<=` vs `<`) where applicable.
- `percentile(p, …)` uses nearest-rank (or linear interpolation; pick one and document) with clamped `p` in `0...100`.
- `isOutlier` uses population standard deviation (or sample; pick one and document). Return `false` if `stdDev == 0`.

### Rationale
These helpers map directly to prior tests: `aboveAverage`, `belowAverage`, `percentile`, `isOutlier`, and define explicit empty-data behavior (`false`).

---

## 2) Dynamic RHS Comparisons (spec-to-spec style)

Enable comparing a left-hand extracted value to a right-hand value derived from the same context (e.g., a dynamic threshold). Implemented via factories that produce `.custom` comparisons to remain backward compatible.

### APIs
```swift
extension ComparativeSpec {
    public static func greaterThan(
        keyPath: KeyPath<Context, Value>,
        rhs: @escaping (Context) -> Value?
    ) -> ComparativeSpec<Context, Value>

    public static func lessThan(
        keyPath: KeyPath<Context, Value>,
        rhs: @escaping (Context) -> Value?
    ) -> ComparativeSpec<Context, Value>

    public static func equalTo(
        keyPath: KeyPath<Context, Value>,
        rhs: @escaping (Context) -> Value?,
        tolerance: Value? = nil
    ) -> ComparativeSpec<Context, Value>

    public static func between(
        keyPath: KeyPath<Context, Value>,
        lower: @escaping (Context) -> Value?,
        upper: @escaping (Context) -> Value?
    ) -> ComparativeSpec<Context, Value>
}
```

### Semantics
- If the RHS closure returns `nil`, the comparison yields `false`.
- `equalTo` honors `tolerance` like the existing initializer.

### Rationale
Replaces ad-hoc “DecisionSpec-to-DecisionSpec” style while staying consistent with 3.0’s extractor-first design.

---

## 3) Multi-Criteria Builder

Provide a compact builder to compose multiple comparative checks and return a single spec using AND/OR. Internally it aggregates `AnySpecification<Context>` and uses existing operators.

### APIs
```swift
public struct ComparativeBuilder<Context> {
    public init()

    /// Add a comparison using a keyPath + comparison.
    @discardableResult
    public mutating func compare<Value: Comparable>(
        keyPath: KeyPath<Context, Value>,
        comparison: ComparativeSpec<Context, Value>.ComparisonType,
        tolerance: Value? = nil
    ) -> Self

    /// Add a comparison using a custom extractor closure.
    @discardableResult
    public mutating func compare<Value: Comparable>(
        extracting: @escaping (Context) -> Value?,
        comparison: ComparativeSpec<Context, Value>.ComparisonType,
        tolerance: Value? = nil
    ) -> Self

    /// Add a dynamic RHS comparison (see Section 2).
    @discardableResult
    public mutating func compare<Value: Comparable>(
        keyPath: KeyPath<Context, Value>,
        rhs: @escaping (Context) -> Value?,
        type: DynamicComparisonType<Value>
    ) -> Self

    public func buildAnd() -> AnySpecification<Context>
    public func buildOr() -> AnySpecification<Context>
}

public enum DynamicComparisonType<Value: Comparable> {
    case greaterThan
    case lessThan
    case equalTo(tolerance: Value? = nil)
    case between(lower: (Any) -> Any?, upper: (Any) -> Any?) // see note below
}
```

Note: The exact shape of `DynamicComparisonType` can be simplified by providing separate overloads for `between` to avoid type erasure. The proposal aims to capture intent; final API should favor clarity, likely via dedicated overloads as listed in Section 2.

### Semantics
- `buildAnd`: returns a spec satisfied only if all added comparisons pass.
- `buildOr`: returns a spec satisfied if any added comparison passes.
- Empty builder:
  - `buildAnd` → returns a spec that always returns `true`.
  - `buildOr` → returns a spec that always returns `false`.

### Rationale
Restores the prior “multi-criteria” capability with a cleaner, explicit type that composes standard ComparativeSpec instances.

---

## 4) Empty-Data Behavior

For statistical helpers (`aboveAverage`, `belowAverage`, `percentile`, `isOutlier`):
- When the data sequence is empty or under `minCount`, the spec returns `false`.
- This matches prior tests and avoids surprising truthiness with missing data.

---

## Examples

```swift
struct C { var value: Double; var threshold: Double; var samples: [Double] }

// Dynamic RHS comparison
let dyn = ComparativeSpec<C, Double>.greaterThan(keyPath: \.value) { ctx in ctx.threshold }

// Statistical helpers
let aboveAvg = ComparativeSpec<C, Double>.aboveAverage(
    comparing: \.value,
    from: \.samples,
    minCount: 3
)

let p90 = ComparativeSpec<C, Double>.percentile(
    90,
    comparing: \.value,
    from: \.samples
)

let outlier = ComparativeSpec<C, Double>.isOutlier(
    comparing: \.value,
    from: \.samples,
    beyondStandardDeviations: 2
)

// Builder
var builder = ComparativeBuilder<C>()
    .compare(keyPath: \.value, comparison: .greaterThan(5))
    .compare(keyPath: \.threshold, comparison: .lessThan(15))

let all = builder.buildAnd()
let any = builder.buildOr()
```

---

## Backward Compatibility
- All additions are new overloads or factories; no breaking changes.
- Existing `.custom` allows internal implementation without widening `ComparisonType`.

## Open Questions
- Percentile definition: nearest-rank vs linear interpolation. Recommend nearest-rank for simplicity.
- Standard deviation: population vs sample. Recommend sample (`n-1`) for small datasets; document clearly.
- Generic constraints: keep `FloatingPoint` for statistical helpers; add `BinaryInteger` overloads only if needed later.

## Acceptance Criteria
- Unit tests for: aboveAverage, belowAverage, percentile, isOutlier, dynamic-RHS greater/less/equal/between, and builder AND/OR paths including empty-builder semantics and empty-data behavior.
- Documentation entries under `Documentation.docc/ComparativeSpec.md` with examples mirroring these helpers.

