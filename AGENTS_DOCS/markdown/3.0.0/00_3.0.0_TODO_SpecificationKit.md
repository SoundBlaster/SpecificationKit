# SpecificationKit v3.0.0 — TODO

This document outlines the pending tasks and enhancements for SpecificationKit v3.0.0, based on uncompleted items from v0.3.0 and new opportunities for the next major version.

Legend: [ ] Pending • (blocked) indicates an external/toolchain blocker

## P0 — Critical Path (Carried Forward from v0.3.0)

### Toolchain-Dependent Features
- [ ] Ensure provider `Context` matches spec `Context` for `@AutoContext`. (blocked by toolchain: conformance macro not available)
- [ ] Provide tests showing `@AutoContext` works with `@Satisfies` without manual context. (blocked by toolchain; provider-based path covered by tests)
- [ ] Add negative tests for `@AutoContext` type mismatches.

## P1 — Important Enhancements

### Macro System Enhancements
- [ ] Leave hooks for future flags (environment/infer) per AutoContext design.
- [ ] Support constructing specs via wrapper parameters, e.g. `@Satisfies(using: CooldownIntervalSpec.self, interval: 10)`.

### Package Management & Distribution
- [ ] Prepare for Swift Package Index: metadata, license confirmation, and semantic tag `3.0.0`.

## P2 — Polish and Performance

### Experimental Features
- [ ] Prototype one experimental macro: `@specsIf(condition:)` or `#composed(...)` or `@deriveSpec(from:)`.
- [ ] Include a brief usage example for the chosen experimental macro.

### Performance Optimization
- [ ] Add performance benchmarks for specification composition and macro-generated code; optimize as needed.
- [ ] Investigate potential bottlenecks in `AnySpecification`; consider `@inlinable` where appropriate.
- [ ] Measure macro compilation impact and optimize macro code to minimize build times.

### Code Quality & Standards
- [ ] Ensure adherence to Swift API Design Guidelines and existing naming conventions.
- [ ] Refactor existing code for clarity and maintainability; ensure consistent use of generics and extensions.

## P3 — New Features for v3.0.0

### Enhanced Property Wrapper Ecosystem
- [ ] Add observed variants for `@Decides` and `@Maybe` to match `@ObservedSatisfies` pattern.
- [ ] Implement `@CachedSatisfies` for expensive specifications with TTL-based invalidation.
- [ ] Add `@ConditionalSatisfies` that can switch between different specifications based on runtime conditions.

### Advanced Specification Types
- [ ] Implement `WeightedSpec` for probabilistic/scoring-based evaluation.
- [ ] Add `HistoricalSpec` that evaluates based on historical data patterns.
- [ ] Create `ComparativeSpec` for relative evaluations between multiple candidates.
- [ ] Implement `ThresholdSpec` for numeric threshold-based conditions.

### Context Provider Enhancements
- [ ] Add `NetworkContextProvider` for remote configuration and feature flags.
- [ ] Implement `PersistentContextProvider` with Core Data or SQLite backing.
- [ ] Create `CompositeContextProvider` that can merge multiple context sources.
- [ ] Add context validation and schema enforcement capabilities.

### Testing & Debugging Tools
- [ ] Implement `SpecificationTracer` for debugging complex specification chains.
- [ ] Add `MockSpecificationBuilder` for easier test specification creation.
- [ ] Create `SpecificationProfiler` for performance analysis of specification trees.
- [ ] Implement specification visualization tools for documentation and debugging.

### Platform-Specific Features
- [ ] Add iOS-specific context providers (device info, app state, permissions).
- [ ] Implement macOS-specific context providers (system preferences, user defaults).
- [ ] Create watchOS-specific specifications for health and activity data.
- [ ] Add tvOS-specific context providers for media and interaction patterns.

### Integration & Interoperability
- [ ] Add SwiftData integration for persistent specifications.
- [ ] Implement Combine publishers for specification state changes.
- [ ] Create Core Data model templates for specification persistence.
- [ ] Add CloudKit synchronization support for distributed specifications.

### Documentation & Examples
- [ ] Create comprehensive tutorial series for common use cases.
- [ ] Add playground examples for interactive learning.
- [ ] Implement sample applications demonstrating real-world patterns.
- [ ] Create migration guide from v2.x to v3.0.0.

## Breaking Changes Considerations for v3.0.0

### API Modernization
- [ ] Review and modernize API naming for Swift 6 compatibility.
- [ ] Consider removing deprecated APIs from v2.x series.
- [ ] Evaluate generic constraints and consider simplifications.
- [ ] Review async/await integration and consider improvements.

### Architecture Improvements
- [ ] Consider splitting core functionality into focused modules.
- [ ] Evaluate dependency injection patterns and improve flexibility.
- [ ] Review thread safety guarantees and document concurrency patterns.
- [ ] Consider performance optimizations that may require API changes.

## Notes
- Items labeled "blocked" are deferred pending toolchain support or external constraints.
- Breaking changes should be carefully evaluated and documented in migration guides.
- New features should maintain backward compatibility where possible within semantic versioning constraints.
- Consider community feedback and real-world usage patterns when prioritizing features.