Определение “Готово” для версии 2.0 SpecificationKit

Ниже приведён подробный план работ на следующую версию библиотеки. Каждый пункт содержит ожидаемый результат/критерий готовности, а также ссылки на материалы репозитория, где описана мотивация или спецификация.

1. Реализация системы макросов

1.1. Макрос @specs (attached macro)
	•	Создать новый таргет SpecificationKitMacros. Макросы должны собираться отдельно от основной библиотеки (см. план в разделе “Implementation Plan” документа о макросах ￼).
	•	Реализовать макрос @specs, который из списка поданных спецификаций генерирует структуру с полем composite: AnySpecification и методами init() и isSatisfiedBy(_) точно так, как описано в макрос‑документации ￼.
	•	Проверки на этапе компиляции: макрос должен удостовериться, что все элементы списка соответствуют протоколу Specification, и что у них совпадают типы Context ￼. При нарушении условий макрос должен выводить понятное сообщение об ошибке.
	•	Тестирование: добавить тесты с использованием MacroTesting, проверяющие корректность сгенерированного кода и вывод ошибок. В частности, проверить:
	1.	Успешное формирование структуры при корректных спецификациях.
	2.	Ошибки при передаче типов с разными Context.
	3.	Ошибки при передаче объектов, не удовлетворяющих протоколу Specification.

1.2. Макрос @AutoContext
	•	Сгенерировать статическое свойство contextProvider и init(), если они не определены вручную. Согласно документации AutoContext должно автоматизировать внедрение провайдера контекста и избавлять от необходимости вручную писать static let contextProvider = … ￼.
	•	Гарантировать типовую безопасность: макрос должен проверять соответствие типа контекста провайдера и типа Context у спецификации, как указано в разделе “Type Safety” ￼.
	•	Поддержать будущие расширения: макрос должен принимать параметры, позволяющие указать собственный тип провайдера (@AutoContext(MyProvider.self)) или режим environment/infer, как описано в таблице будущих расширений ￼.
	•	Тестирование: написать тесты, подтверждающие, что спецификация, отмеченная @AutoContext, корректно работает с property‑wrapper’ом @Satisfies без передачи контекста вручную ￼.

1.3. Дополнительные макросы
	•	Проектирование и черновая реализация нескольких макросов из списка идей: @specsIf(condition:), #composed(…), @deriveSpec(from:) ￼. Основная цель — проработать API и предоставить минимальный прототип хотя бы для одного дополнительного макроса.
	•	Документация: описать назначение каждого макроса и предоставить пример использования.

2. Расширение набора спецификаций

Первый релиз содержит базовые спецификации (TimeSinceEvent, MaxCount, Cooldown и Predicate) ￼. Для второй версии предлагается добавить:
	•	DateRangeSpec – проверяет, что текущее время (now) находится в заданном диапазоне дат (например, для акций, подписок).
	•	FeatureFlagSpec – проверяет наличие логического флага в EvaluationContext (встроенная реализация аналогична фабрике PredicateSpec.flag() ￼, но предоставляет более наглядный тип).
	•	UserSegmentSpec – принимает перечисление сегментов (например, “новый”, “платный”, “бета‑тестер”) и проверяет соответствие пользователя выбранному сегменту.
	•	SubscriptionStatusSpec – проверяет, что подписка активна/истекла/находится на бесплатном периоде.
	•	DateComparisonSpec – обобщает проверку даты по ключу контекста с операциями “раньше/позже/равно”.

Для каждой новой спецификации требуется:
	•	Определить структуру, соответствующую протоколу Specification.
	•	Добавить удобные фабрики (наподобие MaxCountSpec.onlyOnce() ￼).
	•	Написать модульные тесты.

3. Асинхронность и реактивность
	•	Асинхронный ContextProvider: расширить протокол ContextProviding, добавив асинхронный метод currentContext() async throws -> Context. Это позволит получать контекст из сети или базы данных.
	•	AsyncSpecification: дополнить протокол Specification асинхронной версией (func isSatisfiedBy(_:) async throws -> Bool) и создать тип‑стирающую оболочку AnyAsyncSpecification. При этом синхронная версия должна по‑прежнему работать.
	•	Асинхронный property‑wrapper: разработать @AsyncSatisfies или добавить асинхронную инициализацию в существующий @Satisfies, чтобы получать результат через async/await.
	•	Тесты: написать тесты, моделирующие задержки и ошибки при получении контекста.

4. Расширение системы контекста
	•	Провайдер контекста среды (EnvironmentContextProvider): реализовать провайдер, который извлекает данные из SwiftUI @Environment или @AppStorage для упрощённой интеграции в приложениях. В документации AutoContext упомянута возможность использовать SwiftUI Environment ￼.
	•	Инъекция через DI: проработать механизм установки contextProvider через Dependency Injection контейнер (например, через Resolver или Swift’s @Environment(\.key)).
	•	Наблюдение за изменениями: добавить поддержку отслеживания изменений контекста и повторного вычисления спецификаций, возможно через Combine/AsyncSequence.

5. Доработка property‑wrappers
	•	Связка с SwiftUI: обеспечить обновление интерфейса при изменении результата спецификации. Например, интегрировать @Satisfies c @State/@Published.
	•	Расширение API: добавить возможность передачи параметров в спецификацию непосредственно через wrapper (например, @Satisfies(using: CooldownSpec.self, parameter: 10)).
	•	Поддержка обобщённых провайдеров: property‑wrapper должен работать с любым ContextProviding (generic constraint уже описан в примере ￼, нужно перенести в код).

6. Документация и примеры
	•	Обновить README.md: добавить разделы, описывающие макросы @specs и @AutoContext, новые спецификации и асинхронные возможности.
	•	DocC‑документация: сгенерировать DocC для всего публичного API и разместить её в Documentation/SpecificationKit.docc.
	•	Примеры использования: создать новый пример/демо, демонстрирующий работу макросов и авто‑контекста в SwiftUI приложении. Дополнить существующие DemoApp примерами асинхронного контекста.

7. Инфраструктура и CI
	•	GitHub Actions: добавить workflow, который собирает библиотеку и макросы, запускает тесты на macOS, iOS и, при необходимости, tvOS/watchOS.
	•	Swift Package Index: подготовить библиотеку для публикации в Swift Package Index (добавить метаданные).
	•	Версионирование: оформить CHANGELOG и установить новую версию (например, 2.0.0).

8. Тестирование и качество
	•	Тесты для макросов: покрыть макросы тестами на генерацию кода и случаи ошибочного использования.
	•	Тесты для новых спецификаций: обеспечить проверку логики и возможных граничных случаев.
	•	Тесты производительности: провести бенчмарки для композиции спецификаций и асинхронных провайдеров.

9. Оптимизация и поддержка
	•	Оптимизация AnySpecification: уменьшить накладные расходы за счёт уменьшения уровней абстракции или использования inlinable функций.
	•	Анализ накладных расходов макросов: измерить время компиляции при использовании макросов и, при необходимости, оптимизировать их.
	•	Унификация имен: привести все структуры и методы к единому стилю именования (Swift API Design Guidelines).

Следуя этому плану, версия 2.0 будет включать разработанные макросы, расширенную систему спецификаций, поддержку асинхронности и улучшенную интеграцию с приложениями, делая библиотеку ещё более мощной и удобной.